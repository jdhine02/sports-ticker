<!DOCTYPE html>
<html>
<head>
    <!-- Previous head content remains the same -->
    <style>
        /* Previous styles remain the same */
    </style>
</head>
<body>
    <div class="ticker-container">
        <div class="ticker" id="ticker">
            <div class="ticker-item">Loading sports data...</div>
        </div>
    </div>

    <script>
        // Previous constants remain the same
        const API_KEY = 'c1ecaf8db673b709492ce7dd7c4c8120';
        const BASE_URL = 'https://api.the-odds-api.com/v4';
        const CORS_PROXY = 'https://corsproxy.io/?' + encodeURIComponent(BASE_URL);
        const REFRESH_INTERVAL = 60000; // 60 seconds

        // Previous TRACKED_TEAMS and SPORT_FORMATS remain the same

        // Cache management
        function getCacheKey(type) {
            const today = new Date().toISOString().split('T')[0];
            return `${type}_${today}`;
        }

        function getCache(type) {
            const key = getCacheKey(type);
            const cached = localStorage.getItem(key);
            return cached ? JSON.parse(cached) : null;
        }

        function setCache(type, data) {
            const key = getCacheKey(type);
            localStorage.setItem(key, JSON.stringify({
                timestamp: Date.now(),
                data: data
            }));
        }

        // Modified fetch functions
        async function fetchSportsOnce() {
            const cached = getCache('sports');
            if (cached) return cached.data;

            const sports = await fetchWithProxy(`/sports?apiKey=${API_KEY}&all=true`);
            if (sports) setCache('sports', sports);
            return sports;
        }

        async function getActiveGames(sportKey) {
            const cacheKey = `games_${sportKey}`;
            const cached = getCache(cacheKey);
            const now = new Date();
            
            // If we have cached data less than 5 minutes old, use it
            if (cached && (now - new Date(cached.timestamp)) < 300000) {
                return cached.data;
            }

            const games = await fetchWithProxy(
                `/sports/${sportKey}/scores?apiKey=${API_KEY}&daysFrom=1&dateFormat=iso`
            );

            if (games) {
                // Filter for relevant teams and active/upcoming games
                const relevantGames = games.filter(game => 
                    TRACKED_TEAMS.sports[sportKey].some(team => 
                        game.home_team.includes(team) || game.away_team.includes(team)
                    ) && (
                        // Game is today
                        new Date(game.commence_time).toDateString() === now.toDateString() ||
                        // Or game is live
                        (game.completed === false && new Date(game.commence_time) <= now)
                    )
                );

                if (relevantGames.length > 0) {
                    setCache(cacheKey, relevantGames);
                }
                return relevantGames;
            }
            return [];
        }

        // Modified update function
        async function updateTicker() {
            try {
                const sports = await fetchSportsOnce();
                if (!sports) return;

                let allGames = [];
                const sportTitles = {};
                const now = new Date();

                sports.forEach(sport => {
                    sportTitles[sport.key] = sport.title;
                });

                // Only fetch for sports that have tracked teams
                for (const sportKey of Object.keys(TRACKED_TEAMS.sports)) {
                    const games = await getActiveGames(sportKey);
                    if (games && games.length > 0) {
                        games.forEach(game => {
                            allGames.push({
                                ...game,
                                sportKey,
                                sportTitle: sportTitles[sportKey] || sportKey
                            });
                        });
                    }
                }

                // Rest of the display logic remains the same
                const ticker = document.getElementById('ticker');
                
                if (allGames.length === 0) {
                    ticker.innerHTML = '<div class="ticker-item">No live or upcoming games found</div>';
                    return;
                }

                let html = '';
                allGames.forEach(game => {
                    html += createTickerItem(game, game.sportKey, game.sportTitle);
                });
                html += html; // Duplicate for continuous scroll

                ticker.innerHTML = html;

            } catch (error) {
                // Silent error handling
            }
        }

        // Initial update
        updateTicker();

        // Refresh every minute
        setInterval(updateTicker, REFRESH_INTERVAL);
    </script>
</body>
</html>
