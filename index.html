<!DOCTYPE html>
<html>
<head>
    <title>Multi-Sport Ticker</title>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* Same styles as before */
    </style>
</head>
<body>
    <div class="ticker-container">
        <div class="ticker" id="ticker">
            <div class="ticker-item">Loading sports data...</div>
        </div>
    </div>
    <div id="debug" style="display: none;"></div> <!-- Debug hidden for user -->

    <script>
        const API_KEY = 'c1ecaf8db673b709492ce7dd7c4c8120';
        const BASE_URL = 'https://api.the-odds-api.com/v4';
        const CORS_PROXY = 'https://corsproxy.io/?' + encodeURIComponent(BASE_URL);

        const TRACKED_TEAMS = {
            sports: {
                'icehockey_nhl': ['Nashville Predators'],
                'americanfootball_nfl': ['Tennessee Titans', 'Chicago Bears'],
                'soccer_epl': ['Arsenal'],
                'basketball_ncaab': ['Louisville Cardinals', 'Michigan State Spartans'],
                'americanfootball_ncaaf': ['Louisville Cardinals', 'Michigan State Spartans'],
                'basketball_wncaab': ['Louisville Cardinals']
            },
        };

        const SPORT_FORMATS = {
            'icehockey_nhl': { cssClass: 'nhl', periodPrefix: 'P' },
            'americanfootball_nfl': { cssClass: 'nfl', periodPrefix: 'Q' },
            'soccer_epl': { cssClass: 'epl', periodPrefix: '' },
            'basketball_ncaab': { cssClass: 'ncaab', periodPrefix: 'H' },
            'basketball_wncaab': { cssClass: 'wncaab', periodPrefix: 'H' },
            'americanfootball_ncaaf': { cssClass: 'ncaaf', periodPrefix: 'Q' }
        };

        async function fetchWithProxy(endpoint, retries = 3) {
            const url = CORS_PROXY + endpoint;
            try {
                const response = await fetch(url, { headers: { 'Accept': 'application/json' } });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error(`Error fetching ${endpoint}: ${error.message}`);
                if (retries > 0) {
                    console.log(`Retrying ${endpoint}...`);
                    await new Promise(resolve => setTimeout(resolve, 3000)); // Retry after 3 seconds
                    return fetchWithProxy(endpoint, retries - 1);
                }
                return null; // Return null after exhausting retries
            }
        }

        async function getSportsData() {
            const sportsData = await fetchWithProxy(`/sports?apiKey=${API_KEY}&all=true`);
            if (sportsData) console.log("Sports data fetched successfully.");
            return sportsData;
        }

        async function getScoresForSport(sportKey) {
            return await fetchWithProxy(`/sports/${sportKey}/scores?apiKey=${API_KEY}&daysFrom=0&dateFormat=iso`);
        }

        function calculateTimeUntilNextRun(hour, minute) {
            const now = new Date();
            const nextRun = new Date();
            nextRun.setHours(hour, minute, 0, 0);
            if (now >= nextRun) {
                nextRun.setDate(nextRun.getDate() + 1);
            }
            return nextRun - now; // Time difference in milliseconds
        }

        function scheduleDailySportsDataUpdate() {
            const timeUntilNextRun = calculateTimeUntilNextRun(1, 0); // 1:00 AM
            console.log(`Next sports data update scheduled in ${timeUntilNextRun / 1000 / 60} minutes.`);
            setTimeout(() => {
                getSportsData();
                setInterval(getSportsData, 24 * 60 * 60 * 1000); // Run every 24 hours
            }, timeUntilNextRun);
        }

        async function updateTicker() {
            try {
                const sports = await getSportsData();
                if (!sports) {
                    console.error("Failed to fetch sports data for ticker update.");
                    return;
                }

                let allGames = [];
                const sportTitles = {};
                sports.forEach(sport => {
                    sportTitles[sport.key] = sport.title;
                });

                for (const sportKey of Object.keys(TRACKED_TEAMS.sports)) {
                    const games = await getScoresForSport(sportKey);
                    if (games) {
                        const relevantGames = games.filter(game =>
                            TRACKED_TEAMS.sports[sportKey].some(team =>
                                game.home_team.includes(team) || game.away_team.includes(team)
                            )
                        );

                        relevantGames.forEach(game => {
                            allGames.push({ ...game, sportKey, sportTitle: sportTitles[sportKey] || sportKey });
                        });
                    }
                }

                const ticker = document.getElementById('ticker');
                if (allGames.length === 0) {
                    ticker.innerHTML = '<div class="ticker-item">No live or upcoming games found</div>';
                    return;
                }

                let html = '';
                allGames.forEach(game => {
                    html += createTickerItem(game, game.sportKey, game.sportTitle);
                });
                html += html; // Duplicate for continuous scroll

                ticker.innerHTML = html;
                console.log(`Updated ticker with ${allGames.length} games.`);
            } catch (error) {
                console.error("Error updating ticker:", error.message);
            }
        }

        function createTickerItem(game, sportKey, sportTitle) {
            const isLive = game.completed === false && new Date(game.commence_time) <= new Date();
            const status = game.completed ? 'FINAL' : isLive ? 'LIVE' : 'NEXT';
            const statusClass = isLive ? 'live' : (game.completed ? 'final' : 'upcoming');
            const format = SPORT_FORMATS[sportKey];

            return `
                <div class="ticker-item">
                    <span class="league-badge ${format?.cssClass || ''}">${sportTitle}</span>
                    <span class="${statusClass}">${status}</span>
                    ${game.home_team}
                    ${game.scores ?
                        `<span class="score">${game.scores.home || '0'}</span> -
                         <span class="score">${game.scores.away || '0'}</span>` :
                        'vs'
                    }
                    ${game.away_team}
                    ${isLive ?
                        `<span class="period">${formatPeriod(game, sportKey)}</span>` :
                        (!game.completed ?
                            `<span class="period">${formatGameTime(game.commence_time)}</span>` :
                            ''
                        )
                    }
                </div>
            `;
        }

        // Initial setup
        (async () => {
            await getSportsData(); // Fetch sports data immediately on load
            scheduleDailySportsDataUpdate(); // Schedule daily updates
            updateTicker(); // Initial ticker update
            setInterval(updateTicker, 300000); // Refresh ticker every 5 minutes
        })();
    </script>
</body>
</html>
